// Generated using SwiftGen, by O.Halligon â€” https://github.com/AliSoftware/SwiftGen

import Foundation

/**
 This is a convenience class used by the model parsing to reduce the amount of generated code.
 */
public struct Parser {
  /**
   The dictionary we are going to parse.
   */
  public let dictionary: NSDictionary?

  public init(dictionary: NSDictionary?) {
    self.dictionary = dictionary
  }

  /**
   Attempts to fetch a value from the dictionary.
   If the key is missing it will return nil.
   Otherwise, it will attempt to parse the data value.
   */
  public func fetch<T: DataConvertible>(_ key: String, error: (String) throws -> Void) rethrows -> T? {
    guard let value = dictionary?[key] else  {
      return nil
    }
    return try T.parse(data: value, error: error)
  }

  /**
   Attempts to fetch a value from an array.
   If the key is missing it will call the error block and return an empty array.
   Otherwise, it will attempt to parse the array.
   */
  public func fetch<T: DataConvertible>(_ key: String, error: (String) throws -> Void) rethrows -> [T] {
    guard let fetched = dictionary?[key] else {
      try error("The key '\(key)' was not found.")
      return []
    }
    // NOTE: Do not use [Any] here. Casting to NSArray is much faster.
    if let fetchedArray = fetched as? NSArray {
      return try fetchedArray.flatMap { try T.parse(data: $0, error: error) }
    } else {
      try error("The key '\(key)' was the wrong type.")
      return []
    }
  }

  /**
   Attempts to fetch a value from an optional array.
   If the key is missing it will return nil.
   Otherwise, it will attempt to parse the array.
   */
  public func fetch<T: DataConvertible>(_ key: String, error: (String) throws -> Void) rethrows -> [T]? {
    let fetchedOptional = dictionary?[key]
    guard let fetched = fetchedOptional else {
      return nil
    }
    // NOTE: Do not use [Any] here. Casting to NSArray is much faster.
    if let fetchedArray = fetched as? NSArray {
      return try fetchedArray.flatMap { try T.parse(data: $0, error: error) }
    } else {
      try error("The key '\(key)' was the wrong type.")
      return nil
    }
  }
}

/*
 A parse error thrown when parsing models.
 **/
public struct ParseError: Error {
  public let message: String
}

/*
 These protocols are helper protocols which all our models adhere to.
 `DataConvertible` is implemented by any class which we want to parse into a model.
 For example, `String` and `Int` implement this protocol so they are easy to parse.
 This is why they return `Any` instead of a dictionary.
 */

/**
 This protocol is implemented by all the data models generated by SwiftGen.
 It allows you to convert a model to `[String: Any]` and `[String: Any]` to a model.
 */
public protocol DataModel: DataConvertible {
  /**
   Converts a `DataModel` to `[String: Any]` representation.
   */
  func data() -> [String: Any]
}

extension DataModel {
  /**
   This overrides the default method which returns `Any` to return the method that returns `[String: Any]`
   */
  public func dataRepresentation() -> Any {
    return data()
  }
}

/**
 This protocol is implemented by any type which we want to parse.
 This includes types like `String` and `Int` so these functions take `Any` as parameters.
 */
public protocol DataConvertible {
  /**
   Parses data into the current class and attempts to return an instance of the class.
   If a parsing error occurs, the error block will be called with a descriptive `String`.
   Even if a parsing error occurs, the function may attempt to return a 'best effort' representation of itself.
   For instance, it may choose to nil out optional fields.
   */
  static func parse(data: Any, error: (String) throws -> Void) rethrows -> Self?

  /**
   Converts the class back into a data representation.
   This is the opposite of `parse(...)`.
   */
  func dataRepresentation() -> Any
}

/*
 This file implements extensions on common types we want to parse.
 */

extension String: DataConvertible {
  public static func parse(data: Any, error: (String) throws -> Void) rethrows -> String? {
    if let data = data as? String {
      return data
    } else {
      try error("Expected a String, but got \(type(of: data))")
      return nil
    }
  }

  public func dataRepresentation() -> Any {
    return self
  }
}

extension Int: DataConvertible {
  public static func parse(data: Any, error: (String) throws -> Void) rethrows -> Int? {
    if let data = data as? Int {
      return data
    } else {
      try error("Expected an Int, but got \(type(of: data))")
      return nil
    }
  }

  public func dataRepresentation() -> Any {
    return self
  }
}

extension Double: DataConvertible {
  public static func parse(data: Any, error: (String) throws -> Void) rethrows -> Double? {
    if let data = data as? Double {
      return data
    } else {
      try error("Expected an Double, but got \(type(of: data))")
      return nil
    }
  }

  public func dataRepresentation() -> Any {
    return self
  }
}

/**
 This allows us to compare optional arrays for equality.
 */
public func ==<T>(lhs: [T]?, rhs: [T]?) -> Bool {
  switch (lhs, rhs) {
  case (nil, nil):
    return true
  case (.some(let rhs), .some(let lhs)):
    return lhs == rhs
  default:
    return false
  }
}

